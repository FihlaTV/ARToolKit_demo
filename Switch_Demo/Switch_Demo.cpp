// Switch_Demo.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <GL/gl.h>
#include <GL/glut.h>
#include <AR/gsub.h>
#include <AR/video.h>
#include <AR/param.h>
#include <AR/ar.h>
#include<time.h>//时间函数  

//摄像机默认参数
char			*vconf = "../Data/WDM_camera_flipV.xml";
//摄像机特征参数
char           *cparam_name = "../Data/camera_para.dat";
//标识信息
char           *patt_name = "../Data/patt.hiro";

int             xsize, ysize;
int             thresh = 100;
int             count = 0;
ARParam         cparam;
int             patt_id;
double          patt_width = 80.0;
double          patt_center[2] = { 0.0, 0.0 };
double          patt_trans[3][4];

static void   init(void);
static void   cleanup(void);
static void   keyEvent(unsigned char key, int x, int y);
static void   mainLoop(void);
static void   draw(void);

int main(int argc, char **argv)
{
	glutInit(&argc, argv);
	init();
	arVideoCapStart();
	argMainLoop(NULL, NULL, mainLoop);
	return (0);
}

static void mainLoop(void)
{
	ARUint8         *dataPtr;
	ARMarkerInfo    *marker_info; //标志信息struct
	int             marker_num;
	int             j, k;
	if ((dataPtr = (ARUint8 *)arVideoGetImage()) == NULL) {
		//调用延迟
		arUtilSleep(2);
		return;
	}
	if (count == 0) arUtilTimerReset();
	count++;
	argDrawMode2D();
	argDispImage(dataPtr, 0, 0);

	if (arDetectMarker(dataPtr, thresh, &marker_info, &marker_num) < 0) {
		cleanup();
		exit(0);
	}
	//每一帧都要调用，支持诸多功能的完成
	arVideoCapNext();

	k = -1;
	for (j = 0; j < marker_num; j++) {
		if (patt_id == marker_info[j].id) {
			if (k == -1) k = j;
			else if (marker_info[k].cf < marker_info[j].cf) k = j;
		}
	}
	if (k == -1) {
		argSwapBuffers();
		return;
	}
	//获取相机的位置
	arGetTransMat(&marker_info[k], patt_center, patt_width, patt_trans);
	//绘制模型到对应的位置
	draw();

	argSwapBuffers();
}

static void init(void)
{
	ARParam  wparam;

	//打开相机参数文件
	arVideoOpen(vconf);
	//获取视频窗口大小
	arVideoInqSize(&xsize, &ysize);
	//设置相机特征参数
	arParamLoad(cparam_name, 1, &wparam);
	arParamChangeSize(&wparam, xsize, ysize, &cparam);
	//初始化相机
	arInitCparam(&cparam);
	arParamDisp(&cparam);
	//读取多个标识 的定义文件
	patt_id = arLoadPatt(patt_name);
	//打开图像窗口
	argInit(&cparam, 1.0, 0, 0, 0, 0);
}

//cleanup
static void cleanup(void)
{
	arVideoCapStop();
	arVideoClose();
	argCleanup();
}


//绘制3D模型 纯opengl的内容
static void draw(void)
{
	static time_t dwLast = 0;
	static int flag = -1;
	if (clock() - dwLast>100)
	{
		++flag;
		flag = flag % 4;
	}

	double    gl_para[16];
	GLfloat   mat_ambient[] = { 0.0, 0.0, 1.0, 1.0 };
	GLfloat   mat_flash[] = { 0.0, 0.0, 1.0, 1.0 };
	GLfloat   mat_flash_shiny[] = { 50.0 };
	GLfloat   light_position[] = { 100.0,-200.0,200.0,0.0 };
	GLfloat   ambi[] = { 0.1, 0.1, 0.1, 0.1 };
	GLfloat   lightZeroColor[] = { 0.9, 0.9, 0.9, 0.1 };

	argDrawMode3D();
	argDraw3dCamera(0, 0);
	glClearDepth(1.0);
	glClear(GL_DEPTH_BUFFER_BIT);
	glEnable(GL_DEPTH_TEST);
	glDepthFunc(GL_LEQUAL);
	//加载相机转换矩阵
	argConvGlpara(patt_trans, gl_para);
	glMatrixMode(GL_MODELVIEW);
	glLoadMatrixd(gl_para);
	glEnable(GL_LIGHTING);
	glEnable(GL_LIGHT0);
	glLightfv(GL_LIGHT0, GL_POSITION, light_position);
	glLightfv(GL_LIGHT0, GL_AMBIENT, ambi);
	glLightfv(GL_LIGHT0, GL_DIFFUSE, lightZeroColor);
	glMaterialfv(GL_FRONT, GL_SPECULAR, mat_flash);
	glMaterialfv(GL_FRONT, GL_SHININESS, mat_flash_shiny);
	glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient);
	glMatrixMode(GL_MODELVIEW);
	glTranslatef(0.0, 0.0, 25.0);


	if (flag == 0) glutSolidSphere(50, 150, 150);
	else if (flag == 1)glutSolidCube(50.0);
	else if (flag == 2)glutSolidCone(25, 100, 20, 24); 
	else if (flag == 3)glutSolidTorus(10, 40, 24, 24);

	glDisable(GL_LIGHTING);
	glDisable(GL_DEPTH_TEST);
	dwLast = clock();
}


